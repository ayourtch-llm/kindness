[task]
id = "5_12_protocol_parser"
tier = 5
title = "Binary Protocol Parser Combinators"
language = "rust"

[task.description]
text = """
Build a parser combinator library for binary protocols and use it to parse a TLV (type-length-value) format.

Define:
```rust
pub struct Parser<T> {
    pub parse: Box<dyn Fn(&[u8]) -> Result<(T, &[u8]), String>>,
}
```

Implement these combinator constructors:
- `fn u8_parser() -> Parser<u8>` — parse one byte.
- `fn u16_be() -> Parser<u16>` — parse a big-endian u16 (2 bytes).
- `fn u32_be() -> Parser<u32>` — parse a big-endian u32 (4 bytes).
- `fn bytes(n: usize) -> Parser<Vec<u8>>` — parse exactly n bytes.

Implement these methods on `Parser<T>`:
- `fn map<U: 'static>(self, f: impl Fn(T) -> U + 'static) -> Parser<U>` — transform parsed value.
- `fn then<U: 'static>(self, next: Parser<U>) -> Parser<(T, U)>` where T: 'static — sequence two parsers.
- `fn repeat(self, count: usize) -> Parser<Vec<T>>` where T: 'static — run the parser count times, collecting results.

Also implement:
```rust
#[derive(Debug, Clone, PartialEq)]
pub struct TlvRecord {
    pub tag: u8,
    pub value: Vec<u8>,
}

pub fn tlv_parser() -> Parser<TlvRecord>
```
A TLV record is: 1 byte tag, 2 bytes big-endian length, then `length` bytes of value.

`fn parse_tlv_stream(data: &[u8]) -> Result<Vec<TlvRecord>, String>` — parse consecutive TLV records until input is exhausted.
"""

[task.constraints]
time_limit_seconds = 5
must_use = []
forbidden = []

[task.tests]
[[task.tests.cases]]
name = "parse_u8_and_u16"
code = """
let p = u8_parser();
let (val, rest) = (p.parse)(&[0x42, 0x01]).unwrap();
assert_eq!(val, 0x42);
assert_eq!(rest, &[0x01]);

let p2 = u16_be();
let (val2, rest2) = (p2.parse)(&[0x01, 0x02, 0xFF]).unwrap();
assert_eq!(val2, 0x0102);
assert_eq!(rest2, &[0xFF]);
"""

[[task.tests.cases]]
name = "parse_bytes"
code = """
let p = bytes(3);
let (val, rest) = (p.parse)(&[1, 2, 3, 4, 5]).unwrap();
assert_eq!(val, vec![1, 2, 3]);
assert_eq!(rest, &[4, 5]);

let p2 = bytes(10);
let result = (p2.parse)(&[1, 2, 3]);
assert!(result.is_err());
"""

[[task.tests.cases]]
name = "map_combinator"
code = """
let p = u8_parser().map(|b| b as u16 * 2);
let (val, _) = (p.parse)(&[0x05]).unwrap();
assert_eq!(val, 10u16);
"""

[[task.tests.cases]]
name = "then_combinator"
code = """
let p = u8_parser().then(u16_be());
let (val, rest) = (p.parse)(&[0x01, 0x00, 0x02, 0xFF]).unwrap();
assert_eq!(val, (0x01u8, 0x0002u16));
assert_eq!(rest, &[0xFF]);
"""

[[task.tests.cases]]
name = "repeat_combinator"
code = """
let p = u8_parser().repeat(4);
let (val, rest) = (p.parse)(&[10, 20, 30, 40, 50]).unwrap();
assert_eq!(val, vec![10, 20, 30, 40]);
assert_eq!(rest, &[50]);
"""

[[task.tests.cases]]
name = "single_tlv_record"
code = """
// tag=0x01, length=3, value=[0xAA, 0xBB, 0xCC]
let data = vec![0x01, 0x00, 0x03, 0xAA, 0xBB, 0xCC];
let records = parse_tlv_stream(&data).unwrap();
assert_eq!(records.len(), 1);
assert_eq!(records[0], TlvRecord { tag: 0x01, value: vec![0xAA, 0xBB, 0xCC] });
"""

[[task.tests.cases]]
name = "multiple_tlv_records"
code = """
let mut data = Vec::new();
// Record 1: tag=0x01, length=2, value=[0x0A, 0x0B]
data.extend_from_slice(&[0x01, 0x00, 0x02, 0x0A, 0x0B]);
// Record 2: tag=0x02, length=0, value=[]
data.extend_from_slice(&[0x02, 0x00, 0x00]);
// Record 3: tag=0xFF, length=1, value=[0x42]
data.extend_from_slice(&[0xFF, 0x00, 0x01, 0x42]);

let records = parse_tlv_stream(&data).unwrap();
assert_eq!(records.len(), 3);
assert_eq!(records[0].tag, 0x01);
assert_eq!(records[1].tag, 0x02);
assert_eq!(records[1].value, Vec::<u8>::new());
assert_eq!(records[2].value, vec![0x42]);
"""