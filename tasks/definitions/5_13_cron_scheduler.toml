[task]
id = "5_13_cron_scheduler"
tier = 5
title = "Cron Expression Parser and Scheduler"
language = "rust"

[task.description]
text = """
Build a cron expression parser and next-occurrence calculator using manual date math (no external crate).

Define a simple date-time struct:
```rust
#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord)]
pub struct NaiveDateTime {
    pub year: i32,
    pub month: u32,   // 1-12
    pub day: u32,     // 1-31
    pub hour: u32,    // 0-23
    pub minute: u32,  // 0-59
}
```

Implement `NaiveDateTime` with:
- `fn new(year: i32, month: u32, day: u32, hour: u32, minute: u32) -> Self`
- `fn day_of_week(&self) -> u32` — return 0=Sunday, 1=Monday, ..., 6=Saturday. Use Zeller's congruence or Tomohiko Sakamoto's algorithm.

Implement `struct CronExpr` with:
- `fn parse(expr: &str) -> Result<CronExpr, String>` — parse a standard 5-field cron expression: `minute hour day-of-month month day-of-week`. Support:
  - `*` (any value)
  - Exact numbers (e.g., `5`)
  - Ranges (e.g., `1-5`)
  - Lists (e.g., `1,3,5`)
  - Steps (e.g., `*/5`, `1-10/2`)
- `fn next_occurrence(&self, after: &NaiveDateTime) -> NaiveDateTime` — find the next datetime strictly after `after` that matches the cron expression. Search up to 4 years ahead; if none found, panic.

Day-of-week: 0 = Sunday, 7 = Sunday (both valid).

Handle days-per-month correctly, including leap years (divisible by 4, except centuries unless divisible by 400).
"""

[task.constraints]
time_limit_seconds = 5
must_use = []
forbidden = []

[task.tests]
[[task.tests.cases]]
name = "every_minute"
code = """
let cron = CronExpr::parse("* * * * *").unwrap();
let after = NaiveDateTime::new(2024, 1, 1, 12, 30);
let next = cron.next_occurrence(&after);
assert_eq!(next, NaiveDateTime::new(2024, 1, 1, 12, 31));
"""

[[task.tests.cases]]
name = "specific_time"
code = """
let cron = CronExpr::parse("30 9 * * *").unwrap();
let after = NaiveDateTime::new(2024, 6, 15, 9, 30);
// 9:30 is not strictly after, so next is tomorrow at 9:30
let next = cron.next_occurrence(&after);
assert_eq!(next, NaiveDateTime::new(2024, 6, 16, 9, 30));
"""

[[task.tests.cases]]
name = "step_expression"
code = """
let cron = CronExpr::parse("*/15 * * * *").unwrap();
let after = NaiveDateTime::new(2024, 3, 1, 10, 14);
let next = cron.next_occurrence(&after);
assert_eq!(next, NaiveDateTime::new(2024, 3, 1, 10, 15));
"""

[[task.tests.cases]]
name = "month_rollover"
code = """
let cron = CronExpr::parse("0 0 1 * *").unwrap(); // midnight on 1st of each month
let after = NaiveDateTime::new(2024, 1, 15, 0, 0);
let next = cron.next_occurrence(&after);
assert_eq!(next, NaiveDateTime::new(2024, 2, 1, 0, 0));
"""

[[task.tests.cases]]
name = "leap_year_feb29"
code = """
let cron = CronExpr::parse("0 12 29 2 *").unwrap(); // noon on Feb 29
let after = NaiveDateTime::new(2024, 1, 1, 0, 0);
let next = cron.next_occurrence(&after);
assert_eq!(next, NaiveDateTime::new(2024, 2, 29, 12, 0));
"""

[[task.tests.cases]]
name = "day_of_week_filter"
code = """
let cron = CronExpr::parse("0 9 * * 1").unwrap(); // 9am on Mondays
let after = NaiveDateTime::new(2024, 7, 1, 0, 0); // Monday July 1 2024
let next = cron.next_occurrence(&after);
// July 1 2024 is a Monday, so 9am that day
assert_eq!(next, NaiveDateTime::new(2024, 7, 1, 9, 0));
"""

[[task.tests.cases]]
name = "range_and_list"
code = """
let cron = CronExpr::parse("0 9-11 * * *").unwrap(); // 9,10,11 o'clock
let after = NaiveDateTime::new(2024, 1, 1, 10, 0);
let next = cron.next_occurrence(&after);
assert_eq!(next, NaiveDateTime::new(2024, 1, 1, 11, 0));

let cron2 = CronExpr::parse("0,30 * * * *").unwrap(); // :00 and :30
let after2 = NaiveDateTime::new(2024, 1, 1, 5, 0);
let next2 = cron2.next_occurrence(&after2);
assert_eq!(next2, NaiveDateTime::new(2024, 1, 1, 5, 30));
"""
