[task]
id = "3_11_iterator_chain"
tier = 3
title = "Custom Iterator Adapter: MappedFilter"
language = "rust"

[task.description]
text = """
Create a custom iterator adapter that chains a map transformation with a filter
predicate in a single pass.

Define a struct `MappedFilter<I, F, P>` that implements `Iterator`. It takes an
inner iterator, applies a mapping function to each element, and then yields only
those mapped results that satisfy a predicate.

Provide a constructor function:

`fn map_filter<I, T, U, F, P>(iter: I, map_fn: F, pred: P) -> MappedFilter<I, F, P>`

where:
- `I: Iterator<Item = T>`
- `F: Fn(T) -> U`
- `P: Fn(&U) -> bool`

The returned `MappedFilter` iterator should yield items of type `U`. For each
element produced by the inner iterator, apply `map_fn` to get a `U`, then yield
it only if `pred(&u)` returns true. This must be done lazily â€” elements are
processed one at a time as `next()` is called, not eagerly collected.
"""

[task.constraints]
time_limit_seconds = 5
must_use = []
forbidden = []

[task.tests]
[[task.tests.cases]]
name = "test_basic_map_filter"
code = """
let data = vec![1, 2, 3, 4, 5];
let result: Vec<i32> = map_filter(
    data.into_iter(),
    |x| x * 10,
    |x| *x > 20,
).collect();
assert_eq!(result, vec![30, 40, 50]);
"""

[[task.tests.cases]]
name = "test_empty_iterator"
code = """
let data: Vec<i32> = vec![];
let result: Vec<i32> = map_filter(
    data.into_iter(),
    |x| x + 1,
    |x| *x > 0,
).collect();
assert_eq!(result, vec![]);
"""

[[task.tests.cases]]
name = "test_all_filtered_out"
code = """
let data = vec![1, 2, 3];
let result: Vec<i32> = map_filter(
    data.into_iter(),
    |x| x * 2,
    |x| *x > 100,
).collect();
assert_eq!(result, vec![]);
"""

[[task.tests.cases]]
name = "test_none_filtered_out"
code = """
let data = vec![10, 20, 30];
let result: Vec<i32> = map_filter(
    data.into_iter(),
    |x| x + 1,
    |_x| true,
).collect();
assert_eq!(result, vec![11, 21, 31]);
"""

[[task.tests.cases]]
name = "test_type_conversion"
code = """
let data = vec![1, 2, 3, 4, 5];
let result: Vec<String> = map_filter(
    data.into_iter(),
    |x| format!("item_{}", x),
    |s| s.ends_with('3') || s.ends_with('5'),
).collect();
assert_eq!(result, vec!["item_3".to_string(), "item_5".to_string()]);
"""

[[task.tests.cases]]
name = "test_laziness_with_side_effects"
code = """
use std::cell::Cell;
let count = Cell::new(0u32);
let data = vec![1, 2, 3, 4, 5];
let mut iter = map_filter(
    data.into_iter(),
    |x| { count.set(count.get() + 1); x * 2 },
    |x| *x > 4,
);
assert_eq!(count.get(), 0);
assert_eq!(iter.next(), Some(6));
assert_eq!(count.get(), 3);
"""

[[task.tests.cases]]
name = "test_chained_with_std_adapters"
code = """
let data = vec![1, 2, 3, 4, 5, 6, 7, 8];
let result: Vec<i32> = map_filter(
    data.into_iter(),
    |x| x * x,
    |x| *x % 2 == 0,
).take(2).collect();
assert_eq!(result, vec![4, 16]);
"""
